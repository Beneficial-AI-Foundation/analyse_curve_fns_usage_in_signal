#!/usr/bin/env python3
"""
Extract curve25519-dalek public API from SCIP index JSON.

This script parses the SCIP index generated by rust-analyzer and extracts
all public API functions, methods, and constants, organizing them by module
and type in a structured JSON format.

Note: The extracted API depends on the compilation configuration used when
generating the SCIP index. Some platform-specific backends (e.g., u32 vs u64,
AVX2 implementations) may not be present if they weren't compiled. For a
complete API reference including all feature variants, consider using cargo doc
or the docs.rs documentation as the source.
"""

import json
import re
from pathlib import Path
from collections import defaultdict
from datetime import date


def get_project_root():
    """Get the project root directory."""
    current = Path(__file__).resolve().parent
    return current.parent.parent


def parse_symbol_path(symbol_str):
    """
    Parse a SCIP symbol string to extract module and type information.

    Example: 'rust-analyzer cargo curve25519-dalek 4.1.3 scalar/impl#[Scalar]from_bytes_mod_order().'
    Returns: {
        'library': 'curve25519-dalek',
        'version': '4.1.3',
        'module': 'scalar',
        'type': 'Scalar',
        'name': 'from_bytes_mod_order',
        'symbol_type': 'method'
    }
    """
    # Basic pattern: rust-analyzer cargo LIBRARY VERSION MODULE/PATH
    parts = symbol_str.split()
    if len(parts) < 5 or parts[0] != "rust-analyzer":
        return None

    library = parts[2]
    if library != "curve25519-dalek":
        return None

    version = parts[3]

    # Extract the path after version
    rest = " ".join(parts[4:])

    # Parse module and symbol info
    # Examples:
    # - scalar/impl#[Scalar]from_bytes_mod_order().
    # - edwards/EdwardsPoint#compress().
    # - constants/ED25519_BASEPOINT_COMPRESSED.

    result = {
        "library": library,
        "version": version,
        "module": None,
        "type": None,
        "name": None,
        "symbol_type": None,
    }

    # Extract module path
    if "/" in rest:
        module_parts = rest.split("/")
        result["module"] = "/".join(module_parts[:-1])
        symbol_part = module_parts[-1]
    else:
        symbol_part = rest

    # Parse the symbol part
    # Method/function patterns: Type#method(), impl#[Type]method()
    # Constant pattern: CONSTANT_NAME.
    # Type pattern: Type#

    if "impl#[" in symbol_part:
        # impl#[Type]method().
        match = re.match(r"impl#\[([^\]]+)\]([^(\.]+)", symbol_part)
        if match:
            type_str = match.group(1)
            # Clean up type name - remove backticks and path qualifiers
            type_str = type_str.strip("`").split("::")[-1]
            result["type"] = type_str
            result["name"] = match.group(2)
            result["symbol_type"] = "method"
    elif "#" in symbol_part and "(" in symbol_part:
        # Type#method()
        match = re.match(r"([^#]+)#([^(]+)", symbol_part)
        if match:
            type_str = match.group(1).strip("`").split("::")[-1]
            result["type"] = type_str
            result["name"] = match.group(2)
            result["symbol_type"] = "method"
    elif "#" in symbol_part and "(" not in symbol_part and symbol_part.count("#") == 1:
        # Type definition or constant on type
        type_part, name_part = symbol_part.split("#", 1)
        type_str = type_part.strip("`").split("::")[-1]
        result["type"] = type_str
        if name_part and not name_part.startswith("["):
            result["name"] = name_part.rstrip(".")
            result["symbol_type"] = "const"
        else:
            result["symbol_type"] = "type"
    elif "(" in symbol_part:
        # Standalone function
        match = re.match(r"([^(]+)", symbol_part)
        if match:
            result["name"] = match.group(1)
            result["symbol_type"] = "function"
    elif symbol_part.endswith(".") and symbol_part.replace("_", "").replace(".", "").isupper():
        # Constant (all uppercase with underscores)
        result["name"] = symbol_part.rstrip(".")
        result["symbol_type"] = "constant"

    return result


def categorize_function(name, signature):
    """Categorize a function based on its name and signature."""
    name_lower = name.lower()

    # Construction/creation
    if any(x in name_lower for x in ["new", "create", "from", "random", "hash_to"]):
        return "construction"

    # Serialization
    if any(x in name_lower for x in ["to_bytes", "as_bytes", "from_bytes", "to_string"]):
        return "serialization"

    # Compression/Decompression
    if "compress" in name_lower or "decompress" in name_lower:
        if "decompress" in name_lower:
            return "decompression"
        return "compression"

    # Conversion
    if any(x in name_lower for x in ["to_", "as_", "into_"]) and "to_bytes" not in name_lower:
        return "conversion"

    # Multiscalar multiplication (check before scalar multiplication)
    if "multiscalar" in name_lower:
        return "multiscalar_multiplication"

    # Scalar multiplication
    if "mul" in name_lower and any(
        x in name_lower for x in ["scalar", "base", "clamped", "basepoint"]
    ):
        return "scalar_multiplication"

    # Variable base or double base multiplication
    if any(x in name_lower for x in ["variable_base", "double_base", "vartime_double"]):
        return "scalar_multiplication"

    # Arithmetic operations (check after mul operations)
    if any(
        x in name_lower for x in ["add", "sub", "mul", "div", "invert", "square", "pow", "negate"]
    ):
        return "arithmetic"

    # Group operations
    if any(x in name_lower for x in ["cofactor", "torsion", "small_order", "identity", "double"]):
        return "group_operations"

    # Lookup/selection
    if "select" in name_lower:
        return "lookup"

    # Accessors
    if any(x in name_lower for x in ["len", "is_empty", "get", "basepoint"]):
        return "accessor"

    # Utility
    if any(x in name_lower for x in ["clamp", "batch"]):
        return "utility"

    return "other"


def is_public_api(signature_text):
    """Check if a signature indicates a public API."""
    if not signature_text:
        return False
    sig = signature_text.strip()

    # Must start with pub
    if not sig.startswith("pub "):
        return False

    # Exclude struct/enum fields (pub field_name: Type)
    if (
        sig.startswith("pub ")
        and ":" in sig
        and "(" not in sig
        and "fn " not in sig
        and "const " not in sig
        and "static " not in sig
    ):
        return False

    return True


def should_include_module(module_path):
    """Check if a module should be included in the public API."""
    if not module_path:
        return False

    # Exclude test modules
    if "/test" in module_path or module_path.endswith("test"):
        return False

    # Exclude most internal backend modules except specific ones we want
    allowed_backend_modules = {
        "backend",
        "backend/serial/u32/field",
        "backend/serial/u32/scalar",
        "backend/serial/u64/field",
        "backend/serial/u64/scalar",
    }

    if module_path.startswith("backend/"):
        return module_path in allowed_backend_modules

    # Exclude avx2 and other vector backend specifics
    if any(x in module_path for x in ["avx2", "vector", "cpuid", "spec_"]):
        return False

    # Exclude internal trait modules
    if module_path == "traits":
        return False

    return True


def is_trait_implementation(name):
    """Check if a name looks like a trait implementation."""
    return name.startswith("[") and name.endswith("]")


def extract_public_apis(scip_json_path):
    """Extract all public APIs from the SCIP index."""
    with open(scip_json_path, "r") as f:
        data = json.load(f)

    # Organize APIs by module and type
    api_structure = defaultdict(
        lambda: {
            "types": defaultdict(lambda: {"methods": [], "constants": []}),
            "functions": [],
            "constants": [],
        }
    )

    version = None

    # Process all documents
    for doc in data.get("documents", []):
        relative_path = doc.get("relative_path", "")

        # Only process curve25519-dalek source files
        if not relative_path.startswith("curve25519-dalek/src/"):
            continue

        # Process symbols in this document
        for symbol_info in doc.get("symbols", []):
            symbol_str = symbol_info.get("symbol", "")
            sig_doc = symbol_info.get("signature_documentation", {})
            signature = sig_doc.get("text", "")

            # Only include public APIs
            if not is_public_api(signature):
                continue

            # Parse the symbol
            parsed = parse_symbol_path(symbol_str)
            if not parsed or not parsed["name"]:
                continue

            if not version:
                version = parsed["version"]

            module = parsed["module"] or "root"

            # Filter modules
            if not should_include_module(module):
                continue

            symbol_type = parsed["symbol_type"]
            type_name = parsed["type"]
            name = parsed["name"]

            # Skip trait implementations
            if is_trait_implementation(name):
                continue

            # Categorize
            category = categorize_function(name, signature)

            # Build the API entry
            api_entry = {"name": name, "signature": signature.strip()}

            if category != "other":
                api_entry["category"] = category

            # Detect if this is actually a constant (pub const NAME:) not a const fn
            # pub const fn is a method, pub const NAME: is a constant
            is_constant = (
                "pub const " in signature or "pub static " in signature
            ) and "fn " not in signature

            # Add to appropriate location in structure
            if is_constant and type_name:
                # Constant on a type
                api_structure[module]["types"][type_name]["constants"].append(api_entry)
            elif symbol_type == "method" and type_name:
                # Method on a type
                api_structure[module]["types"][type_name]["methods"].append(api_entry)
            elif symbol_type == "const" and type_name:
                # Constant on a type
                api_structure[module]["types"][type_name]["constants"].append(api_entry)
            elif symbol_type == "function":
                # Standalone function
                api_structure[module]["functions"].append(api_entry)
            elif symbol_type == "constant":
                # Module-level constant
                constant_entry = {"name": name, "signature": signature.strip()}
                # Try to extract the type from signature
                type_match = re.search(r":\s*(&)?(\w+)", signature)
                if type_match:
                    constant_entry["type"] = type_match.group(2)
                    if type_match.group(1):
                        constant_entry["type"] = "&" + constant_entry["type"]

                # Check for feature gates
                if "feature" in signature or "#[cfg" in str(symbol_info.get("documentation", [])):
                    constant_entry["feature_gated"] = "precomputed-tables"

                api_structure[module]["constants"].append(constant_entry)

    return api_structure, version


def build_output_json(api_structure, version):
    """Build the final output JSON structure."""
    output = {
        "library": "curve25519-dalek",
        "version": version or "4.1.3",
        "generated": date.today().isoformat(),
        "modules": {},
    }

    # Convert defaultdict to regular dict and clean up
    for module, content in sorted(api_structure.items()):
        module_data = {}

        # Add types with their methods and constants
        if content["types"]:
            module_data["types"] = {}
            for type_name, type_content in sorted(content["types"].items()):
                type_data = {}

                if type_content["constants"]:
                    type_data["constants"] = sorted(
                        type_content["constants"], key=lambda x: x["name"]
                    )

                if type_content["methods"]:
                    type_data["methods"] = sorted(type_content["methods"], key=lambda x: x["name"])

                if type_data:
                    module_data["types"][type_name] = type_data

        # Add standalone functions
        if content["functions"]:
            module_data["functions"] = sorted(content["functions"], key=lambda x: x["name"])

        # Add module-level constants
        if content["constants"]:
            module_data["constants"] = sorted(content["constants"], key=lambda x: x["name"])

        if module_data:
            output["modules"][module] = module_data

    return output


def main():
    """Main function."""
    project_root = get_project_root()
    scip_json_path = project_root / "data" / "index_scip_curve25519-4.1.3.json"
    output_path = project_root / "data" / "curve25519-dalek-public-api-generated.json"

    if not scip_json_path.exists():
        print(f"Error: SCIP index not found at {scip_json_path}")
        return 1

    print(f"Reading SCIP index from {scip_json_path}")
    api_structure, version = extract_public_apis(scip_json_path)

    print(f"Extracted public APIs for curve25519-dalek {version}")
    print(f"Modules found: {len(api_structure)}")

    # Build output JSON
    output_json = build_output_json(api_structure, version)

    # Count statistics
    total_items = 0
    for module_data in output_json["modules"].values():
        total_items += len(module_data.get("functions", []))
        total_items += len(module_data.get("constants", []))
        for type_data in module_data.get("types", {}).values():
            total_items += len(type_data.get("methods", []))
            total_items += len(type_data.get("constants", []))

    print(f"Total public API items: {total_items}")

    # Write output
    with open(output_path, "w") as f:
        json.dump(output_json, f, indent=2)

    print(f"\nGenerated public API JSON: {output_path}")
    print("\nNote: The extracted API reflects what was compiled in the SCIP index.")
    print("Platform-specific backends (e.g., u32/u64, SIMD) may vary based on")
    print("compilation configuration. Some items in the original API may be missing")
    print("if they weren't present in this particular SCIP compilation.")
    print("\nTo replace the existing file, run:")
    print(f"  mv {output_path} {project_root / 'data' / 'curve25519-dalek-public-api.json'}")

    return 0


if __name__ == "__main__":
    exit(main())
